{"meta":{"title":"人间失格","subtitle":"Pain is inevitable. Suffering is optional. 痛苦不可避免，但可以选择是否受苦。","description":"陈显鹏个人博客","author":"Pxichen","url":"http://pxichen.github.io"},"pages":[{"title":"关于博主","date":"2019-12-12T12:11:08.000Z","updated":"2019-12-14T07:55:45.422Z","comments":true,"path":"about/index.html","permalink":"http://pxichen.github.io/about/index.html","excerpt":"","text":"目前大四在读，喜欢篮球，跑步，看电影，听歌，当然也喜欢编程了，相信阳光总在风雨后，fighting!!!"},{"title":"categories","date":"2019-12-13T03:05:08.000Z","updated":"2019-12-13T03:19:27.493Z","comments":true,"path":"categories/index.html","permalink":"http://pxichen.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-13T03:27:58.000Z","updated":"2019-12-14T11:10:12.968Z","comments":true,"path":"tags/index.html","permalink":"http://pxichen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot整合缓存（Cache的详细使用）","slug":"SpringBoot整合缓存（Cache的详细使用）","date":"2019-12-24T06:38:00.000Z","updated":"2019-12-24T09:12:14.774Z","comments":true,"path":"2019/12/24/SpringBoot整合缓存（Cache的详细使用）/","link":"","permalink":"http://pxichen.github.io/2019/12/24/SpringBoot%E6%95%B4%E5%90%88%E7%BC%93%E5%AD%98%EF%BC%88Cache%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%EF%BC%89/","excerpt":"","text":"缓存的简单使用和整合Ehcache,Redis的使用1、JSR-107 2、Spring缓存抽象 3、几个重要概念&amp;缓存注解 4、缓存使用 5、整合Redis 一、JSR107简介 Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry和 Expiry。 CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 Entry是一个存储在Cache中的key-value对。 Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 二、Spring缓存抽象 Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们的开发； Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； 每次调用需要缓存功能的方法时，Spring会检查指定参数的指定的目标方法是否已经被调用过； 如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 使用Spring缓存抽象时我们需要关注以下两点； 1、确定方法需要被缓存以及它们的缓存策略 2、从缓存中读取之前缓存存储的数据 ** 缓存的工作原理** 在方法运行之前，先去缓存按value查找Cache，第一次获取不到就会创建 去Cache中查找Entry，使用一个key，默认用方法的参数 key是按某种规则创建的，默认是使用的SimpleKeyGenerator生成 SimpleKeyGenerator的生成策略： 如果没有参数，key=new SimpleKey()； 如果有一个参数，key=参数的值 如果有多个参数：key=new SimpleKey(params); 如果查到，直接返回；没有查到就调用目标方法 将目标方法返回的结果放到缓存里面 三、几个重要概念&amp;缓存注解 Cache 缓存接口，定义缓存操作。 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置 @CacheEvict 清空缓存 @CachePut 更新缓存 @EnableCaching @EnableCaching keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 四、缓存使用 引入spring-boot-starter-cache模块 @EnableCaching开启缓存 使用缓存注解 切换为其他缓存 五、整合redis实现缓存 引入 依赖 spring-boot-starter-data-redis、spring-data-redisredis.clientsjedis 配置redis连接地址spring.redis.host=你的本地ip地址（localhost） 使用ReditTemplate操作redis redisTemplate.opsForValue();//操作字符串 redisTemplate.opsForHash();//操作hash redisTemplate.opsForList();//操作list redisTemplate.opsForSet();//操作set redisTemplate.opsForZSet();//操作有序set 六、搭建过程 创建数据库cache和表department、employee 创建javaBean封装数据 整合MyBatis操作数据 配置数据源 使用注解版的MyBatis @MapperScan指定需要扫描的mapper接口所在的包 @MapperScan(“com.dahaiwuliang.cache.mapper”) springboot 快速体验缓存 开启基于注解的缓存@EnableCaching 在service上写注解@Cacheable @CacheEvict @CachePut 默认使用的是ConcurrentMapCacheManager–&gt;ConcurrentMapCache;把数据保存在ConcurrentMap中开发中常常会用一些缓存中间件：redis、memcached、ehcache 源码示例代码地址： 链接 点我下载","categories":[{"name":"Cache","slug":"Cache","permalink":"http://pxichen.github.io/categories/Cache/"},{"name":"SpringBoot","slug":"Cache/SpringBoot","permalink":"http://pxichen.github.io/categories/Cache/SpringBoot/"}],"tags":[{"name":"Cache","slug":"Cache","permalink":"http://pxichen.github.io/tags/Cache/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://pxichen.github.io/tags/SpringBoot/"}],"keywords":[{"name":"Cache","slug":"Cache","permalink":"http://pxichen.github.io/categories/Cache/"},{"name":"SpringBoot","slug":"Cache/SpringBoot","permalink":"http://pxichen.github.io/categories/Cache/SpringBoot/"}]},{"title":"Mybatis动态SQL中trim标签的用法","slug":"Mybatis动态SQL中trim标签的用法","date":"2019-12-18T02:13:00.000Z","updated":"2019-12-18T03:03:44.250Z","comments":true,"path":"2019/12/18/Mybatis动态SQL中trim标签的用法/","link":"","permalink":"http://pxichen.github.io/2019/12/18/Mybatis%E5%8A%A8%E6%80%81SQL%E4%B8%ADtrim%E6%A0%87%E7%AD%BE%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"mybatis动态sql中的trim标签的使用 trim标签的四个属性: prefix（前缀），prefixOverrides（去掉第一个and或者是or），suffix（后缀），suffixOverrides（去掉最后一个）. prefix，suffix 表示在trim标签包裹的部分的前面或者后面添加内容（注意：是没有prefixOverrides，suffixOverrides的情况下）. 如果有prefixOverrides，suffixOverrides 表示覆盖Overrides中的内容。 如果只有prefixOverrides，suffixOverrides 表示删除。 trim标记是一个格式化的标记，可以完成set或者是where标记的功能,下面是具体的例子：** 1.where标记 ** 12345678910111213141516171819&lt;select id&#x3D;&quot;queryList&quot; resultType&#x3D;&quot;Course&quot; parameterType&#x3D;&quot;cn.edu.gufe.dto.CourseQueryDto&quot;&gt; SELECT * FROM t_course &lt;trim prefix&#x3D;&quot;WHERE &quot; prefixOverrides&#x3D;&quot;AND |OR &quot;&gt; &lt;if test&#x3D;&quot;classify !&#x3D; null&quot;&gt; AND classify &#x3D; #&#123;classify&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;subClassify !&#x3D; null&quot;&gt; AND sub_classify &#x3D; #&#123;subClassify&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt; AND username &#x3D; #&#123;username&#125; &lt;&#x2F;if&gt; &lt;&#x2F;trim&gt; ORDER BY weight DESC &lt;if test&#x3D;&quot;start !&#x3D; null and end !&#x3D; null&quot;&gt; LIMIT #&#123;start, jdbcType&#x3D;INTEGER&#125; , #&#123;end, jdbcType&#x3D;INTEGER&#125; &lt;&#x2F;if&gt; &lt;&#x2F;select&gt; 这是一个动态查询课程的sql语句，生成的语句如下： 由此可以看出，prefix：会给语句加一个前缀，而prefixoverride：会去掉第一个and或者是or，从而保证语句的准确性，当然我们也可以使用其他的方式实现，例如： 1234567891011121314&lt;select id&#x3D;&quot;getUser&quot; resultMap&#x3D;&quot;BaseResultMap&quot;&gt; SELECT * FROM t_user u,t_account a WHERE a.user_id&#x3D;u.id &lt;if test&#x3D;&quot;username!&#x3D;null&quot;&gt; AND u.username&#x3D;#&#123;username&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;age!&#x3D;0&quot;&gt; AND u.age&#x3D;#&#123;age&#125; &lt;&#x2F;if&gt; &lt;&#x2F;select&gt; 这是在where后面加一个条件，如果没有条件时，可以将例子中的a.user_id=u.id替换成1=1也是可以的，只要能正确拼接生成正确的sql语句即可。 ** 2.set标记 ** 我们看一个例子： 123456789update user &lt;trim prefix&#x3D;&quot;set&quot; suffixoverride&#x3D;&quot;,&quot; suffix&#x3D;&quot; where id &#x3D; #&#123;id&#125; &quot;&gt; &lt;if test&#x3D;&quot;name !&#x3D; null and name.length()&gt;0&quot;&gt; name&#x3D;#&#123;name&#125; , &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;gender !&#x3D; null and gender.length()&gt;0&quot;&gt; gender&#x3D;#&#123;gender&#125; , &lt;&#x2F;if&gt; &lt;&#x2F;trim&gt; 简单分析一下：假如说name和gender的值都不为null的话打印的SQL为：** update user set name=’xx’ , gender=’xx’ where id=’x’ **，自动为语句加了一个set前缀和where后缀，上面三个属性的意义如下，其中prefix意义和where标记中相同，suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样），suffix：为语句添加一个后缀。","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://pxichen.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://pxichen.github.io/tags/Mybatis/"},{"name":"动态SQL","slug":"动态SQL","permalink":"http://pxichen.github.io/tags/%E5%8A%A8%E6%80%81SQL/"}],"keywords":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://pxichen.github.io/categories/Mybatis/"}]},{"title":"Maven搭建ssm项目","slug":"Maven搭建ssm项目","date":"2019-12-15T12:54:00.000Z","updated":"2019-12-15T13:10:12.855Z","comments":true,"path":"2019/12/15/Maven搭建ssm项目/","link":"","permalink":"http://pxichen.github.io/2019/12/15/Maven%E6%90%AD%E5%BB%BAssm%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"基于Maven搭建ssm项目 一,准备工作： 需要在windos中安装jdk并配置环境变量； 需要安装eclipse或idea； 在eclipse或idea中配置tomocat； 在eclipse或idea中搭建maven本地仓库。 二，创建maven项目","categories":[{"name":"Maven","slug":"Maven","permalink":"http://pxichen.github.io/categories/Maven/"},{"name":"SpringMVC","slug":"Maven/SpringMVC","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/"},{"name":"Spring","slug":"Maven/SpringMVC/Spring","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/Spring/"},{"name":"Mybatis","slug":"Maven/SpringMVC/Spring/Mybatis","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/Spring/Mybatis/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://pxichen.github.io/tags/maven/"},{"name":"spring","slug":"spring","permalink":"http://pxichen.github.io/tags/spring/"},{"name":"springmvc","slug":"springmvc","permalink":"http://pxichen.github.io/tags/springmvc/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://pxichen.github.io/tags/Mybatis/"}],"keywords":[{"name":"Maven","slug":"Maven","permalink":"http://pxichen.github.io/categories/Maven/"},{"name":"SpringMVC","slug":"Maven/SpringMVC","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/"},{"name":"Spring","slug":"Maven/SpringMVC/Spring","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/Spring/"},{"name":"Mybatis","slug":"Maven/SpringMVC/Spring/Mybatis","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/Spring/Mybatis/"}]},{"title":"Hexo admin 插件遇到的问题","slug":"Hexo-admin-插件遇到的问题","date":"2019-12-15T10:11:00.000Z","updated":"2019-12-16T00:42:59.946Z","comments":true,"path":"2019/12/15/Hexo-admin-插件遇到的问题/","link":"","permalink":"http://pxichen.github.io/2019/12/15/Hexo-admin-%E6%8F%92%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"搭建hexo博客用了两天时间，然后就是在不断优化，主要是这个博客管理工具啊，折腾了好久，所以把遇到的问题做一下记录，好了，直接看遇到的错误：1.当我们Deploy的时候，可能会报如下错误： 12345678910111213141516171819fatal: HttpRequestException encountered.bash: &#x2F;dev&#x2F;tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &#39;https:&#x2F;&#x2F;github.com&#39;: No errorFATAL Something&#39;s wrong. Maybe you can find the solution here: http:&#x2F;&#x2F;hexo.io&#x2F;do cs&#x2F;troubleshooting.htmlError: fatal: HttpRequestException encountered. ʱ bash: &#x2F;dev&#x2F;tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &#39;https:&#x2F;&#x2F;github.com&#39;: No error at ChildProcess.&lt;anonymous&gt; (F:\\blog\\huahua462.github.io\\node_modules\\hexo-u til\\lib\\spawn.js:37:17) at emitTwo (events.js:126:13) at ChildProcess.emit (events.js:214:7) at ChildProcess.cp.emit (F:\\blog\\huahua462.github.io\\node_modules\\cross-spaw n\\lib\\enoent.js:40:29) at maybeClose (internal&#x2F;child_process.js:925:16) at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:209:5) 解决：在你的本地blog文件夹下有一个名为“_config.yml”的配置文件，这个称为站点配置文件,使用vscode或其它编辑器打开将: 1234deploy:type: git repo: https:&#x2F;&#x2F;github.com&#x2F;GitHub注册用户名&#x2F;GitHub注册用户名.github.io.git branch: master 修改成： 1234deploy: type: git repo: git@github.com:你GitHub注册用户名&#x2F;你GitHub注册用户名.github.io.git branch: master 完美解决。 2.还有可能报这种错误： 1Config value “admin.deployCommand” not found 如图：解决方案：在本地博客项目中创建hexo-deploy.sh文件并设置权限： 1$ touch hexo-deploy.sh; chmod a+x hexo-deploy.sh 文件里面写上如下代码： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 打开本地博客根目录_config.yml配置文件，在之前配置的admin配置信息下加入deployCommand: ‘./hexo-deploy.sh’ 信息如图所示(上面的用户名和密码可配可不配): 3.在解决完上述错误信息后，将会报出deploy Error: spawn UNKNOWN错误信息解决方法:打开node_modules目录下hexo-admin目录下deploy.js将: 1var proc &#x3D; spawn(command, [message], &#123;detached: true&#125;); 改为： 1var proc &#x3D; spawn((process.platform &#x3D;&#x3D;&#x3D; &quot;win32&quot; ? &quot;hexo.cmd&quot; : &quot;hexo&quot;), [&#39;d&#39;]); 如图所示： 再重新部署一下 还有一点，如果是windows的话，一定要记住配置git的环境变量！否则也会报错。 参考资料： What is admin.deployCommand? deploy Error: spawn UNKNOWN","categories":[{"name":"hexo","slug":"hexo","permalink":"http://pxichen.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://pxichen.github.io/tags/hexo/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://pxichen.github.io/categories/hexo/"}]},{"title":"玩转Bootstrap框架","slug":"玩转Bootstrap框架","date":"2019-12-14T11:04:27.000Z","updated":"2019-12-14T11:04:32.067Z","comments":true,"path":"2019/12/14/玩转Bootstrap框架/","link":"","permalink":"http://pxichen.github.io/2019/12/14/%E7%8E%A9%E8%BD%ACBootstrap%E6%A1%86%E6%9E%B6/","excerpt":"","text":"准备开写了","categories":[],"tags":[],"keywords":[]},{"title":"多线程相关问题","slug":"多线程相关问题","date":"2019-12-14T10:13:00.000Z","updated":"2019-12-14T11:10:45.092Z","comments":true,"path":"2019/12/14/多线程相关问题/","link":"","permalink":"http://pxichen.github.io/2019/12/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"有时间再写","categories":[{"name":"多线程","slug":"多线程","permalink":"http://pxichen.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://pxichen.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"keywords":[{"name":"多线程","slug":"多线程","permalink":"http://pxichen.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Docker容器安装镜像文件（Tomcat，Mysql）","slug":"Docker容器安装T镜像文件（Tomcat，Mysql）","date":"2019-12-12T01:53:56.000Z","updated":"2019-12-16T05:47:16.574Z","comments":true,"path":"2019/12/12/Docker容器安装T镜像文件（Tomcat，Mysql）/","link":"","permalink":"http://pxichen.github.io/2019/12/12/Docker%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85T%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%EF%BC%88Tomcat%EF%BC%8CMysql%EF%BC%89/","excerpt":"","text":"1、Dockedr简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker守护进程(daemon)： 一般在宿主主机后台运行，等待接收来自客户端的消息。 docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止。 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare（教程使用）、VirtualBox； ​ 2）、导入虚拟机文件centos7.ova； ​ （1）、首先点击“打开虚拟机： ​ （2）、选择虚拟机文件centos7.ova后点击“打开”: ​ （3）、新虚拟机名称和存储路径可以自行修改，点击“导入”： ​ （4）、系统可能会跳出错误提示，直接点击“重试，等待导入完成： ​ （5）、导入成功后，选择该虚拟机，点击菜单栏的”编辑“–”虚拟网络编辑器“： ​ （6）、选择VMNET0–桥接模式–选择当前电脑连接互联网使用的网卡后点击”确定“： ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、查看linux的ip地址 1$ ip addr ​ 8）、使用客户端连接linux(SecureCRT)； &nbsp;下载地址&nbsp;点我下载 ​ （1）、输入主机名（ip地址）用户名(root)后点击”连接“： ​ （2）、点击”接受并保存“： ​ （3）、输入密码123456： 2）、在linux虚拟机上安装dockerDocker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。 社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。 社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。 安装步骤： ​ 1、Docker 要求 CentOS 系统的内核版本高于 3.10 。 通过 uname -r 命令查看当前的内核版本 1[root@localhost ~]#uname -r ​ ​ 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 1[root@localhost ~]#sudo yum update ​ 3、卸载旧版本(如果安装过旧版本的话) 1[root@localhost ~]#sudo yum remove docker docker-common docker-selinux docker-engine ​ 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1[root@localhost ~]#sudo yum install -y yum-utils device-mapper-persistent-data lvm2 ​ 5、设置yum源 12345[root@localhost ~]#sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo这个源是国外网站的，有可能会很慢，可以改成阿里云提供的镜像，二者执行一个即可：[root@localhost ~]#sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo ​ 6、可以查看所有仓库中所有docker版本，并选择特定版本安装 1[root@localhost ~]#yum list docker-ce --showduplicates | sort -r ​ 7、安装docker 12[root@localhost ~]#sudo yum install docker-ce #这里安装的是最新稳定版18.09.6[root@localhost ~]#sudo yum install &lt;FQPN&gt; # 例如：sudo yum install docker-ce-17.12.1.ce ​ 8、启动并加入开机启动 12[root@localhost ~]#sudo systemctl start docker[root@localhost ~]#sudo systemctl enable docker ​ 9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) 1[root@localhost ~]#docker version ​ 10、停止docker 1[root@localhost ~]#sudo systemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作 软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 12345678910111213141516171819202122232425262728 1、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、查看运行中的容器[root@localhost ~]# docker ps 5、停止运行中的容器[root@localhost ~]# docker stop 容器的id6、查看所有的容器[root@localhost ~]# docker ps -a7、启动容器[root@localhost ~]# docker start 容器id8、删除一个容器[root@localhost ~]# docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 更多命令参看 https://docs.docker.com/engine/reference/commandline/docker/ 可以参考每一个镜像的文档 ### 3）、安装MySQL示例 1docker pull mysql 错误的启动 12345678910111213[root@localhost ~]# docker run --name mysql01 -d mysqlf077e80f0b5463d7680413c91bf11265e3ad2b6e66f932977535057fc517381amysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf077e80f0b54 mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01//错误日志[root@localhost ~]# docker logs f077e80f0b54error: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4d177d6518a6 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb931bbc89831306645910006ef55407d85ead7f0db763778240529f9d3cfc578[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb931bbc89831 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02","categories":[{"name":"Docker","slug":"Docker","permalink":"http://pxichen.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://pxichen.github.io/tags/docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"http://pxichen.github.io/categories/Docker/"}]}]}