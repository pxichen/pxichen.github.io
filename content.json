{"meta":{"title":"人间失格","subtitle":"Pain is inevitable. Suffering is optional. 痛苦不可避免，但可以选择是否受苦。","description":"陈显鹏个人博客","author":"Pxichen","url":"http://pxichen.github.io"},"pages":[{"title":"关于博主","date":"2019-12-12T12:11:08.000Z","updated":"2019-12-14T07:55:45.422Z","comments":true,"path":"about/index.html","permalink":"http://pxichen.github.io/about/index.html","excerpt":"","text":"目前大四在读，喜欢篮球，跑步，看电影，听歌，当然也喜欢编程了，相信阳光总在风雨后，fighting!!!"},{"title":"categories","date":"2019-12-13T03:05:08.000Z","updated":"2019-12-13T03:19:27.493Z","comments":true,"path":"categories/index.html","permalink":"http://pxichen.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-13T03:27:58.000Z","updated":"2019-12-14T11:10:12.968Z","comments":true,"path":"tags/index.html","permalink":"http://pxichen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot整合缓存（Cache的详细使用）","slug":"SpringBoot整合缓存（Cache的详细使用）","date":"2019-12-24T06:38:00.000Z","updated":"2019-12-24T09:12:14.774Z","comments":true,"path":"2019/12/24/SpringBoot整合缓存（Cache的详细使用）/","link":"","permalink":"http://pxichen.github.io/2019/12/24/SpringBoot%E6%95%B4%E5%90%88%E7%BC%93%E5%AD%98%EF%BC%88Cache%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%EF%BC%89/","excerpt":"","text":"缓存的简单使用和整合Ehcache,Redis的使用1、JSR-107 2、Spring缓存抽象 3、几个重要概念&amp;缓存注解 4、缓存使用 5、整合Redis 一、JSR107简介 Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry和 Expiry。 CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 Entry是一个存储在Cache中的key-value对。 Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 二、Spring缓存抽象 Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们的开发； Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； 每次调用需要缓存功能的方法时，Spring会检查指定参数的指定的目标方法是否已经被调用过； 如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 使用Spring缓存抽象时我们需要关注以下两点； 1、确定方法需要被缓存以及它们的缓存策略 2、从缓存中读取之前缓存存储的数据 ** 缓存的工作原理** 在方法运行之前，先去缓存按value查找Cache，第一次获取不到就会创建 去Cache中查找Entry，使用一个key，默认用方法的参数 key是按某种规则创建的，默认是使用的SimpleKeyGenerator生成 SimpleKeyGenerator的生成策略： 如果没有参数，key=new SimpleKey()； 如果有一个参数，key=参数的值 如果有多个参数：key=new SimpleKey(params); 如果查到，直接返回；没有查到就调用目标方法 将目标方法返回的结果放到缓存里面 三、几个重要概念&amp;缓存注解 Cache 缓存接口，定义缓存操作。 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置 @CacheEvict 清空缓存 @CachePut 更新缓存 @EnableCaching @EnableCaching keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 四、缓存使用 引入spring-boot-starter-cache模块 @EnableCaching开启缓存 使用缓存注解 切换为其他缓存 五、整合redis实现缓存 引入 依赖 spring-boot-starter-data-redis、spring-data-redisredis.clientsjedis 配置redis连接地址spring.redis.host=你的本地ip地址（localhost） 使用ReditTemplate操作redis redisTemplate.opsForValue();//操作字符串 redisTemplate.opsForHash();//操作hash redisTemplate.opsForList();//操作list redisTemplate.opsForSet();//操作set redisTemplate.opsForZSet();//操作有序set 六、搭建过程 创建数据库cache和表department、employee 创建javaBean封装数据 整合MyBatis操作数据 配置数据源 使用注解版的MyBatis @MapperScan指定需要扫描的mapper接口所在的包 @MapperScan(“com.dahaiwuliang.cache.mapper”) springboot 快速体验缓存 开启基于注解的缓存@EnableCaching 在service上写注解@Cacheable @CacheEvict @CachePut 默认使用的是ConcurrentMapCacheManager–&gt;ConcurrentMapCache;把数据保存在ConcurrentMap中开发中常常会用一些缓存中间件：redis、memcached、ehcache 源码示例代码地址： 链接 点我下载","categories":[{"name":"Cache","slug":"Cache","permalink":"http://pxichen.github.io/categories/Cache/"},{"name":"SpringBoot","slug":"Cache/SpringBoot","permalink":"http://pxichen.github.io/categories/Cache/SpringBoot/"}],"tags":[{"name":"Cache","slug":"Cache","permalink":"http://pxichen.github.io/tags/Cache/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://pxichen.github.io/tags/SpringBoot/"}],"keywords":[{"name":"Cache","slug":"Cache","permalink":"http://pxichen.github.io/categories/Cache/"},{"name":"SpringBoot","slug":"Cache/SpringBoot","permalink":"http://pxichen.github.io/categories/Cache/SpringBoot/"}]},{"title":"Mybatis动态SQL中trim标签的用法","slug":"Mybatis动态SQL中trim标签的用法","date":"2019-12-18T02:13:00.000Z","updated":"2019-12-18T03:03:44.250Z","comments":true,"path":"2019/12/18/Mybatis动态SQL中trim标签的用法/","link":"","permalink":"http://pxichen.github.io/2019/12/18/Mybatis%E5%8A%A8%E6%80%81SQL%E4%B8%ADtrim%E6%A0%87%E7%AD%BE%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"mybatis动态sql中的trim标签的使用 trim标签的四个属性: prefix（前缀），prefixOverrides（去掉第一个and或者是or），suffix（后缀），suffixOverrides（去掉最后一个）. prefix，suffix 表示在trim标签包裹的部分的前面或者后面添加内容（注意：是没有prefixOverrides，suffixOverrides的情况下）. 如果有prefixOverrides，suffixOverrides 表示覆盖Overrides中的内容。 如果只有prefixOverrides，suffixOverrides 表示删除。 trim标记是一个格式化的标记，可以完成set或者是where标记的功能,下面是具体的例子：** 1.where标记 ** 12345678910111213141516171819&lt;select id&#x3D;&quot;queryList&quot; resultType&#x3D;&quot;Course&quot; parameterType&#x3D;&quot;cn.edu.gufe.dto.CourseQueryDto&quot;&gt; SELECT * FROM t_course &lt;trim prefix&#x3D;&quot;WHERE &quot; prefixOverrides&#x3D;&quot;AND |OR &quot;&gt; &lt;if test&#x3D;&quot;classify !&#x3D; null&quot;&gt; AND classify &#x3D; #&#123;classify&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;subClassify !&#x3D; null&quot;&gt; AND sub_classify &#x3D; #&#123;subClassify&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;username !&#x3D; null&quot;&gt; AND username &#x3D; #&#123;username&#125; &lt;&#x2F;if&gt; &lt;&#x2F;trim&gt; ORDER BY weight DESC &lt;if test&#x3D;&quot;start !&#x3D; null and end !&#x3D; null&quot;&gt; LIMIT #&#123;start, jdbcType&#x3D;INTEGER&#125; , #&#123;end, jdbcType&#x3D;INTEGER&#125; &lt;&#x2F;if&gt; &lt;&#x2F;select&gt; 这是一个动态查询课程的sql语句，生成的语句如下： 由此可以看出，prefix：会给语句加一个前缀，而prefixoverride：会去掉第一个and或者是or，从而保证语句的准确性，当然我们也可以使用其他的方式实现，例如： 1234567891011121314&lt;select id&#x3D;&quot;getUser&quot; resultMap&#x3D;&quot;BaseResultMap&quot;&gt; SELECT * FROM t_user u,t_account a WHERE a.user_id&#x3D;u.id &lt;if test&#x3D;&quot;username!&#x3D;null&quot;&gt; AND u.username&#x3D;#&#123;username&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;age!&#x3D;0&quot;&gt; AND u.age&#x3D;#&#123;age&#125; &lt;&#x2F;if&gt; &lt;&#x2F;select&gt; 这是在where后面加一个条件，如果没有条件时，可以将例子中的a.user_id=u.id替换成1=1也是可以的，只要能正确拼接生成正确的sql语句即可。 ** 2.set标记 ** 我们看一个例子： 123456789update user &lt;trim prefix&#x3D;&quot;set&quot; suffixoverride&#x3D;&quot;,&quot; suffix&#x3D;&quot; where id &#x3D; #&#123;id&#125; &quot;&gt; &lt;if test&#x3D;&quot;name !&#x3D; null and name.length()&gt;0&quot;&gt; name&#x3D;#&#123;name&#125; , &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;gender !&#x3D; null and gender.length()&gt;0&quot;&gt; gender&#x3D;#&#123;gender&#125; , &lt;&#x2F;if&gt; &lt;&#x2F;trim&gt; 简单分析一下：假如说name和gender的值都不为null的话打印的SQL为：** update user set name=’xx’ , gender=’xx’ where id=’x’ **，自动为语句加了一个set前缀和where后缀，上面三个属性的意义如下，其中prefix意义和where标记中相同，suffixoverride：去掉最后一个逗号（也可以是其他的标记，就像是上面前缀中的and一样），suffix：为语句添加一个后缀。","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://pxichen.github.io/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://pxichen.github.io/tags/Mybatis/"},{"name":"动态SQL","slug":"动态SQL","permalink":"http://pxichen.github.io/tags/%E5%8A%A8%E6%80%81SQL/"}],"keywords":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://pxichen.github.io/categories/Mybatis/"}]},{"title":"Maven搭建ssm项目","slug":"Maven搭建ssm项目","date":"2019-12-15T12:54:00.000Z","updated":"2019-12-15T13:10:12.855Z","comments":true,"path":"2019/12/15/Maven搭建ssm项目/","link":"","permalink":"http://pxichen.github.io/2019/12/15/Maven%E6%90%AD%E5%BB%BAssm%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"基于Maven搭建ssm项目 一,准备工作： 需要在windos中安装jdk并配置环境变量； 需要安装eclipse或idea； 在eclipse或idea中配置tomocat； 在eclipse或idea中搭建maven本地仓库。 二，创建maven项目","categories":[{"name":"Maven","slug":"Maven","permalink":"http://pxichen.github.io/categories/Maven/"},{"name":"SpringMVC","slug":"Maven/SpringMVC","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/"},{"name":"Spring","slug":"Maven/SpringMVC/Spring","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/Spring/"},{"name":"Mybatis","slug":"Maven/SpringMVC/Spring/Mybatis","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/Spring/Mybatis/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://pxichen.github.io/tags/maven/"},{"name":"spring","slug":"spring","permalink":"http://pxichen.github.io/tags/spring/"},{"name":"springmvc","slug":"springmvc","permalink":"http://pxichen.github.io/tags/springmvc/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://pxichen.github.io/tags/Mybatis/"}],"keywords":[{"name":"Maven","slug":"Maven","permalink":"http://pxichen.github.io/categories/Maven/"},{"name":"SpringMVC","slug":"Maven/SpringMVC","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/"},{"name":"Spring","slug":"Maven/SpringMVC/Spring","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/Spring/"},{"name":"Mybatis","slug":"Maven/SpringMVC/Spring/Mybatis","permalink":"http://pxichen.github.io/categories/Maven/SpringMVC/Spring/Mybatis/"}]},{"title":"Hexo admin 插件遇到的问题","slug":"Hexo-admin-插件遇到的问题","date":"2019-12-15T10:11:00.000Z","updated":"2019-12-16T00:42:59.946Z","comments":true,"path":"2019/12/15/Hexo-admin-插件遇到的问题/","link":"","permalink":"http://pxichen.github.io/2019/12/15/Hexo-admin-%E6%8F%92%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"搭建hexo博客用了两天时间，然后就是在不断优化，主要是这个博客管理工具啊，折腾了好久，所以把遇到的问题做一下记录，好了，直接看遇到的错误：1.当我们Deploy的时候，可能会报如下错误： 12345678910111213141516171819fatal: HttpRequestException encountered.bash: &#x2F;dev&#x2F;tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &#39;https:&#x2F;&#x2F;github.com&#39;: No errorFATAL Something&#39;s wrong. Maybe you can find the solution here: http:&#x2F;&#x2F;hexo.io&#x2F;do cs&#x2F;troubleshooting.htmlError: fatal: HttpRequestException encountered. ʱ bash: &#x2F;dev&#x2F;tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &#39;https:&#x2F;&#x2F;github.com&#39;: No error at ChildProcess.&lt;anonymous&gt; (F:\\blog\\huahua462.github.io\\node_modules\\hexo-u til\\lib\\spawn.js:37:17) at emitTwo (events.js:126:13) at ChildProcess.emit (events.js:214:7) at ChildProcess.cp.emit (F:\\blog\\huahua462.github.io\\node_modules\\cross-spaw n\\lib\\enoent.js:40:29) at maybeClose (internal&#x2F;child_process.js:925:16) at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:209:5) 解决：在你的本地blog文件夹下有一个名为“_config.yml”的配置文件，这个称为站点配置文件,使用vscode或其它编辑器打开将: 1234deploy:type: git repo: https:&#x2F;&#x2F;github.com&#x2F;GitHub注册用户名&#x2F;GitHub注册用户名.github.io.git branch: master 修改成： 1234deploy: type: git repo: git@github.com:你GitHub注册用户名&#x2F;你GitHub注册用户名.github.io.git branch: master 完美解决。 2.还有可能报这种错误： 1Config value “admin.deployCommand” not found 如图：解决方案：在本地博客项目中创建hexo-deploy.sh文件并设置权限： 1$ touch hexo-deploy.sh; chmod a+x hexo-deploy.sh 文件里面写上如下代码： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 打开本地博客根目录_config.yml配置文件，在之前配置的admin配置信息下加入deployCommand: ‘./hexo-deploy.sh’ 信息如图所示(上面的用户名和密码可配可不配): 3.在解决完上述错误信息后，将会报出deploy Error: spawn UNKNOWN错误信息解决方法:打开node_modules目录下hexo-admin目录下deploy.js将: 1var proc &#x3D; spawn(command, [message], &#123;detached: true&#125;); 改为： 1var proc &#x3D; spawn((process.platform &#x3D;&#x3D;&#x3D; &quot;win32&quot; ? &quot;hexo.cmd&quot; : &quot;hexo&quot;), [&#39;d&#39;]); 如图所示： 再重新部署一下 还有一点，如果是windows的话，一定要记住配置git的环境变量！否则也会报错。 参考资料： What is admin.deployCommand? deploy Error: spawn UNKNOWN","categories":[{"name":"hexo","slug":"hexo","permalink":"http://pxichen.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://pxichen.github.io/tags/hexo/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://pxichen.github.io/categories/hexo/"}]},{"title":"玩转Bootstrap框架","slug":"玩转Bootstrap框架","date":"2019-12-14T11:04:27.000Z","updated":"2019-12-14T11:04:32.067Z","comments":true,"path":"2019/12/14/玩转Bootstrap框架/","link":"","permalink":"http://pxichen.github.io/2019/12/14/%E7%8E%A9%E8%BD%ACBootstrap%E6%A1%86%E6%9E%B6/","excerpt":"","text":"准备开写了","categories":[],"tags":[],"keywords":[]},{"title":"多线程相关问题","slug":"多线程相关问题","date":"2019-12-14T10:13:00.000Z","updated":"2019-12-25T08:05:32.582Z","comments":true,"path":"2019/12/14/多线程相关问题/","link":"","permalink":"http://pxichen.github.io/2019/12/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"一. 目录 什么是并发与并行 什么是进程与线程 线程生命周期 线程安全问题 什么是线程安全问题 线程安全问题解决方案 线程死锁 线程通信 线程特性 多线程控制 线程池 二.什么是并发与并行创建多线程是为了解决高并发问题的，所以我们要先了解什么是并发与并行 并行：多个处理器或多核处理器同时处理多个任务。 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。 三.什么是进程与线程进程： 进程是正在运行的程序的实例。 进程是线程的容器，即一个进程中可以开启多个线程。 比如打开一个浏览器、打开一个word等操作，都会创建进程。 线程： 线程是进程内部的一个独立执行单元； 一个进程可以同时并发运行多个线程； 比如进程可以理解为医院，线程是挂号、就诊、缴费、拿药等业务活动 多线程：多个线程并发执行 四.线程创建Java中线程有四种创建方式： 继承Thread类 实现Runnable接口 实现Callable接口 线程池1. 继承Thread类 1.1创建自定义线程类 12345678public class MyThread extends Thread &#123; @Override public void run() &#123; for (int i &#x3D; 0; i&lt;10; i++)&#123; System.out.println(&quot;mythread线程正在执行：&quot;+new Date().getTime()); &#125; &#125;&#125; 1.2 创建测试类 1234567891011 public class ThreadCreateDemo &#123; public static void main(String[] args)&#123; &#x2F;&#x2F;1.创建自定义线程 MyThread thread &#x3D; new MyThread(); thread.start(); &#x2F;&#x2F;2.主线程循环打印 for (int i&#x3D;0; i&lt;10; i++)&#123; System.out.println(&quot;main主线程正在执行：&quot;+new Date().getTime()); &#125; &#125;&#125; 2. 实现Runnable接口 2.1 创建自定义类实现Runnable接口 1234567 public class MyRunable implements Runnable &#123; public void run() &#123; for (int i&#x3D;0; i&lt;10; i++)&#123; System.out.println(&quot;MyRunnable线程正在执行：&quot;+new Date().getTime()); &#125; &#125;&#125; 2.2 创建测试类 1234567891011 public class ThreadCreateDemo &#123; public static void main(String[] args)&#123; &#x2F;&#x2F;1.创建自定义线程 Thread thread &#x3D; new Thread(new MyRunable()); thread.start(); &#x2F;&#x2F;2.主线程循环打印 for (int i&#x3D;0; i&lt;10; i++)&#123; System.out.println(&quot;main主线程正在执行：&quot;+new Date().getTime()); &#125; &#125;&#125; 3. 实现Callable接口3.1 创建自定义类实现Callable接口 12345678 public class MyCallable implements Callable&lt;String&gt; &#123; public String call() throws Exception &#123; for (int i&#x3D;0; i&lt;10; i++)&#123; System.out.println(&quot;MyCallable正在执行：&quot;+new Date().getTime()); &#125; return &quot;MyCallable执行完毕！&quot;; &#125;&#125; 3.2 创建测试类 123456789101112 public class ThreadCreateDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask task &#x3D; new FutureTask(new MyCallable()); Thread thread &#x3D; new Thread(task); thread.start(); for (int i&#x3D;0; i&lt;10; i++)&#123; System.out.println(&quot;main主线程正在执行：&quot;+new Date().getTime()); &#125; System.out.println(task.get()); &#125;&#125; 4. 线程池-Executor4.1创建自定义类实现Runnable接口 1234567public class MyRunable implements Runnable &#123; public void run() &#123; for (int i&#x3D;0; i&lt;10; i++)&#123; System.out.println(&quot;MyRunnable线程正在执行：&quot;+new Date().getTime()); &#125; &#125;&#125; 4,2创建测试类 123456789101112 public class ThreadCreateDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; &#x2F;&#x2F;1.使用Executors创建线程池 ExecutorService executorService &#x3D; Executors.newFixedThreadPool(10); &#x2F;&#x2F;2.通过线程池执行线程 executorService.execute(new MyRunable()); &#x2F;&#x2F;3.主线程循环打印 for (int i&#x3D;0; i&lt;10; i++)&#123; System.out.println(&quot;main主线程正在执行：&quot;+new Date().getTime()); &#125; &#125;&#125; 各种方式比较 5.1 实现接口和继承Thread类比较 接口更适合多个相同的程序代码的线程去共享同一个资源。 接口可以避免java中的单继承的局限性。 接口代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable接口的线程，不能直接放入继承Thread的类。 5.2 Runnable和Callable接口比较 相同点： 两者都是接口； 两者都可用来编写多线程程序； 两者都需要调用Thread.start()启动线程； 不同点： 实现Callable接口的线程能返回执行结果；而实现Runnable接口的线程不能返回结果； Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的不允许抛异常； 实现Callable接口的线程可以调用Future.cancel取消执行 ，而实现Runnable接口的线程不能 注意点： Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！ 五.线程生命周期 1.新建 new关键字创建了一个线程之后，该线程就处于新建状态 JVM为线程分配内存，初始化成员变量值 2.就绪 当线程对象调用了start()方法之后，该线程处于就绪状态 JVM为线程创建方法栈和程序计数器，等待线程调度器调度 3.运行 就绪状态的线程获得CPU资源，开始运行run()方法，该线程进入运行状态 4.阻塞 线程调用sleep()方法主动放弃所占用的处理器资源 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞 线程试图获得一个同步锁（同步监视器），但该同步锁正被其他线程所持有。 线程在等待某个通知（notify） 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法 5.死亡 线程会以如下3种方式结束，结束后就处于死亡状态： run()或call()方法执行完成，线程正常结束。 六.线程安全问题1. 什么是线程安全问题？如果有多个线程同时运行同一个实现了Runnable接口的类，程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的；反之，则是线程不安全的。 2.问题演示模拟春节抢购车票。 1.第一步：创建售票线程类12345678910111213141516171819public class Ticket implements Runnable &#123; private int ticktNum &#x3D; 100; public void run() &#123; while(true)&#123; if(ticktNum &gt; 0)&#123; &#x2F;&#x2F;1.模拟出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;2.打印进程号和票号，票数减1 String name &#x3D; Thread.currentThread().getName(); System.out.println(&quot;线程&quot;+name+&quot;售票：&quot;+ticktNum--); &#125; &#125; &#125;&#125; 2.第二步：创建测试类123456789101112public class TicketDemo &#123; public static void main(String[] args)&#123; Ticket ticket &#x3D; new Ticket(); Thread thread1 &#x3D; new Thread(ticket, &quot;窗口1&quot;); Thread thread2 &#x3D; new Thread(ticket, &quot;窗口2&quot;); Thread thread3 &#x3D; new Thread(ticket, &quot;窗口3&quot;); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 运行结果如下： 程序出现了两个问题： 相同的票数,比如5这张票被卖了两回。 不存在的票，比如0票与-1票，是不存在的。 3.问题分析 线程安全问题都是由全局变量及静态变量引起的。 若每个线程对全局变量、静态变量只读，不写，一般来说，这个变量是线程安全的； 若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 综上所述，线程安全问题根本原因: 线程在操作共享的数据； 共享数据的线程代码有多条； 线程对共享数据有写操作； 4.问题解决（线程同步）要解决以上线程问题，只要在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行共享资源操作,Java引入了7种线程同步机制,主要是是前三种。 同步代码块（synchronized） 同步方法（synchronized） 同步锁（ReenreantLock） 特殊域变量（volatile） 局部变量（ThreadLocal） 阻塞队列（LinkedBlockingQueue） 原子变量（Atomic*） 4.1. 同步代码块（synchronized）同步代码块 ： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 语法: 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁: 1234对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 1. 锁对象可以是任意类型。 2. 多个线程要使用同一把锁。注意：在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 我们把刚才售票的案例使用同步代码块，代码如下： 123456789101112131415161718192021222324public class Ticket implements Runnable &#123; private int ticktNum &#x3D; 100; &#x2F;&#x2F;定义锁对象 Object obj &#x3D; new Object(); public void run() &#123; while(true)&#123; synchronized (obj)&#123; if(ticktNum &gt; 0)&#123; &#x2F;&#x2F;1.模拟出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;2.打印进程号和票号，票数减1 String name &#x3D; Thread.currentThread().getName(); System.out.println(&quot;线程&quot;+name+&quot;售票：&quot;+ticktNum--); &#125; &#125; &#125; &#125;&#125; 执行结果如下： 4.2 同步方法（synchronized）同步方法： 1使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 格式： 123public synchronized void method()&#123; 可能会产生线程安全问题的代码 &#125; 同步锁是谁? 121.对于非static方法,同步锁就是this。2.对于static方法,同步锁是当前方法所在类的字节码对象(类名.class)。把售票的案例使用同步方法，代码如下： 1234567891011121314151617181920212223242526public class Ticket implements Runnable &#123; private int ticktNum &#x3D; 100; &#x2F;&#x2F;定义锁对象 Object obj &#x3D; new Object(); public void run() &#123; while(true)&#123; sellTicket(); &#125; &#125; private synchronized void sellTicket()&#123; if(ticktNum &gt; 0)&#123; &#x2F;&#x2F;1.模拟出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;2.打印进程号和票号，票数减1 String name &#x3D; Thread.currentThread().getName(); System.out.println(&quot;线程&quot;+name+&quot;售票：&quot;+ticktNum--); &#125; &#125;&#125; 执行结果如下： 4.3 同步锁（ReenreantLock）同步锁： 1java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块&#x2F;同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 同步锁方法： 12public void lock() :加同步锁。public void unlock() :释放同步锁。 把开始的案例使用重入锁代码如下： 1234567891011121314151617181920212223242526272829public class Ticket implements Runnable &#123; private int ticktNum &#x3D; 100; &#x2F;&#x2F;定义锁对象：构造函数参数为线程是否公平获取锁true-公平；false-不公平，即由某个线程独占，默认是false Lock lock &#x3D; new ReentrantLock(true); public void run() &#123; while(true)&#123; lock.lock(); try&#123; &#x2F;&#x2F;加锁 if(ticktNum &gt; 0)&#123; &#x2F;&#x2F;1.模拟出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;2.打印进程号和票号，票数减1 String name &#x3D; Thread.currentThread().getName(); System.out.println(&quot;线程&quot;+name+&quot;售票：&quot;+ticktNum--); &#125; &#125; finally &#123; &#x2F;&#x2F;放锁 lock.unlock(); &#125; &#125; &#125;&#125; 执行结果如下： 5.Synchronized和Lock区别1234561.synchronized是java内置关键字，在jvm层面，Lock是个java类；2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 七.线程死锁1.什么是死锁？多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力。然而，并发执行也带来了新的问题–死锁。 所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 2.死锁产生的必要条件以下这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 123456781.互斥条件进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。2.不可剥夺条件进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。3.请求与保持条件进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。4.循环等待条件存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合&#123;Pl, P2, …, pn&#125;，其中Pi等 待的资源被P(i+1)占有（i&#x3D;0, 1, …, n-1)，Pn等待的资源被P0占有，如图所示。 3.死锁代码试例123456789101112131415161718192021222324252627282930313233public class DeadLock implements Runnable &#123; private static Object obj1 &#x3D; new Object();&#x2F;&#x2F;定义成静态变量，使线程可以共享实例 private static Object obj2 &#x3D; new Object();&#x2F;&#x2F;定义成静态变量，使线程可以共享实例 public int flag &#x3D; 0; public void run() &#123; if(flag &#x3D;&#x3D; 0)&#123; System.out.println(&quot;flag：&quot;+flag); synchronized (obj1)&#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj2)&#123; System.out.println(&quot;flag：&quot;+flag); &#125; &#125; &#125; if(flag &#x3D;&#x3D; 1)&#123; System.out.println(&quot;flag：&quot;+flag); synchronized (obj2)&#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj1)&#123; System.out.println(&quot;flag：&quot;+flag); &#125; &#125; &#125; &#125;&#125; 12345678910111213public class DeadLockDemo &#123; public static void main(String[] args)&#123; DeadLock deadLock1 &#x3D; new DeadLock(); DeadLock deadLock2 &#x3D; new DeadLock(); deadLock2.flag &#x3D; 1; Thread thread1 &#x3D; new Thread(deadLock1); Thread thread2 &#x3D; new Thread(deadLock2); thread1.start(); thread2.start(); &#125;&#125; 执行结果：只打印两个flag值，表示死锁产生 4.死锁处理 预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。 避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。 检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。 解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。 5.死锁预防预防死锁是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现。 5.1 破坏“互斥”条件1“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。 5.2 破坏“占有并等待”条件12345破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。 5.3 破坏“不可抢占”条件12345破坏“不可抢占”条件就是允许对资源实行抢夺。方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。 5.4 破坏“循环等待”条件1破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。 6.死锁避免避免死锁不严格限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。 6.1 有序资源分配法该算法实现步骤如下： 12345671.必须为所有资源统一编号，例如打印机为1、传真机为2、磁盘为3等2.同类资源必须一次申请完，例如打印机和传真机一般为同一个机器，必须同时申请3.不同类资源必须按顺序申请例如：有两个进程P1和P2，有两个资源R1和R2P1请求资源：R1、R2P2请求资源：R1、R2这样就破坏了环路条件，避免了死锁的发生。 6.2 银行家算法银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格•迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。流程图如下：银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。 12345678设进程i提出请求REQUEST [i]，则银行家算法按如下规则进行判断。1. 如果REQUEST [i]&lt;&#x3D; NEED[i，j]，则转（2)；否则，出错。2. 如果REQUEST [i]&lt;&#x3D; AVAILABLE[i]，则转（3)；否则，等待。3. 系统试探分配资源，修改相关数据：AVAILABLE[i]-&#x3D;REQUEST[i];&#x2F;&#x2F;可用资源数-请求资源数ALLOCATION[i]+&#x3D;REQUEST[i];&#x2F;&#x2F;已分配资源数+请求资源数NEED[i]-&#x3D;REQUEST[i];&#x2F;&#x2F;需要资源数-请求资源数4. 系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。 6.3 顺序加锁当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。 123456789例如以下两个线程就会死锁：Thread 1:lock A (when C locked) lock B (when C locked) wait for CThread 2: wait for A wait for Block C (when A locked) 如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。 例如以下两个线程就不会死锁 12345678Thread 1: lock A lock Block CThread 2: wait for A wait for Bwait for C 按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景。 6.4 限时加锁限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试 以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景： 12345678910Thread 1 locks A Thread 2 locks B Thread 1 attempts to lock B but is blocked Thread 2 attempts to lock A but is blocked Thread 1’s lock attempt on B times out Thread 1 backs up and releases A as well Thread 1 waits randomly (e.g. 257 millis) before retrying. Thread 2’s lock attempt on A times out Thread 2 backs up and releases B as well Thread 2 waits randomly (e.g. 43 millis) before retrying. 在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁。 这种方式有两个缺点： 121.当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。2,Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。 6.5 死锁检测预防和避免死锁系统开销大且不能充分利用资源，更好的方法是不采取任何限制性措施，而是提供检测和解脱死锁的手段，这就是死锁检测和恢复。 死锁检测数据结构： 12341.E是现有资源向量（existing resource vector），代码每种已存在资源的总数2.A是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）3.C是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数4.R是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量 死锁检测步骤： 12341.寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。2.如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步3.如果没有这样的进程，那么算法终止4.算法结束时，所有没有标记过的进程都是死锁进程。 6.6死锁恢复利用抢占恢复。 12临时将某个资源从它的当前所属进程转移到另一个进程。这种做法很可能需要人工干预，主要做法是否可行需取决于资源本身的特性。 利用回滚恢复 1周期性的将进程的状态进行备份，当发现进程死锁后，根据备份将该进程复位到一个更早的，还没有取得所需的资源的状态，接着就把这些资源分配给其他死锁进程。 通过杀死进程恢复 12最直接简单的方式就是杀死一个或若干个进程。尽可能保证杀死的进程可以从头再来而不带来副作用。 七.线程通信1.为什么要线程通信多个线程并发执行时，在默认情况下CPU是随机切换线程的，有时我们希望CPU按我们的规律执行线程，此时就需要线程之间协调通信。 2.线程通信的方式12345671.休眠唤醒方式：Object的wait、notify、notifyAllCondition的await、signal、signalAll2.CountDownLatch：用于某个线程A等待若干个其他线程执行完之后，它才执行3.CyclicBarrier：一组线程等待至某个状态之后再全部同时执行4.Semaphore：用于控制对某组资源的访问权限&#96; 2.1 休眠唤醒方式12345Object和Condition休眠唤醒区别:1.object wait()必须在synchronized（同步锁）下使用， 2.object wait()必须要通过Nodify()方法进行唤醒 3.condition await() 必须和Lock（互斥锁&#x2F;共享锁）配合使用4.condition await() 必须通过 signal() 方法进行唤醒 2.2 CountDownLatch方式123CountDownLatch是在java1.5被引入的，存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。 每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。 2.3 CyclicBarrier方式CyclicBarrier是在java1.5被引入的，存在于java.util.concurrent包下。CyclicBarrier实现让一组线程等待至某个状态之后再全部同时执行。CyclicBarrier底层是三个线程同时启动. 2.4 Semaphore方式Semaphore是在java1.5被引入的，存在于java.util.concurrent包下。Semaphore用于控制对某组资源的访问权限。 3.wait和sleep有什么区别？123•类的不同：sleep() 来自 Thread，wait() 来自 Object。•释放锁：sleep() 不释放锁；wait() 释放锁。•用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()&#x2F;notifyAll()直接唤醒。 4.notify和notifyAll有什么区别？1notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。 5.wait和notify区别 1234都是Object中的方法wait和notify执行前线程都必须获得对象锁wait的作用是使当前线程进行等待notify的作用是通知其他等待当前线程的对象锁的线程 八.线程特性多线程编程要保证满足三个特性：原子性、可见性、有序性。 1.原子性原子性，即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 1.可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。显然，对于单线程来说，可见性问题是不存在的。 1.有序性有序性即程序执行的顺序按照代码的先后顺序执行。 九.多线程控制类为了保证多线程的三个特性，Java引入了很多线程控制机制，下面是其中常用的几种： 1234ThreadLocal原子类Lock类Volatile关键字 1.ThreadLocalThreadLocal提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal，比如数据库连接Connection，每个请求处理线程都需要，但又不相互影响，就是用ThreadLocal实现。 2.原子类Java的java.util.concurrent.atomic包里面提供了很多可以进行原子操作的类，分为以下四类： 1234原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong原子更新数组：AtomicIntegerArray、AtomicLongArray原子更新引用：AtomicReference、AtomicStampedReference等原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。 3.Lock类3.1 Lock接口关系图 123Lock和ReadWriteLock是两大锁的根接口Lock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。ReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。 3.2 可重入锁不可重入锁，即线程请求它已经拥有的锁时会阻塞。可重入锁，即线程可以进入它已经拥有的锁的同步代码块。 12345678910111213141516171819public class ReentrantLockTest &#123; public static void main(String[] args) throws InterruptedException &#123; ReentrantLock lock &#x3D; new ReentrantLock(); for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) &#123; lock.lock(); &#125; for(int i&#x3D;1;i&lt;&#x3D;3;i++)&#123; try &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 3.3 读写锁读写锁，即可以同时读，读的时候不能写；不能同时写，写的时候不能读。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.multithread.thread;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;&#x2F;** * 读写操作类 *&#x2F;public class ReadWriteLockDemo &#123; private Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;(); &#x2F;&#x2F;创建一个读写锁实例 private ReadWriteLock rw &#x3D; new ReentrantReadWriteLock(); &#x2F;&#x2F;创建一个读锁 private Lock r &#x3D; rw.readLock(); &#x2F;&#x2F;创建一个写锁 private Lock w &#x3D; rw.writeLock(); &#x2F;** * 读操作 * * @param key * @return *&#x2F; public Object get(String key) &#123; r.lock(); System.out.println(Thread.currentThread().getName() + &quot;读操作开始执行......&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; return map.get(key); &#125; finally &#123; r.unlock(); System.out.println(Thread.currentThread().getName() + &quot;读操作执行完成......&quot;); &#125; &#125; &#x2F;** * 写操作 * * @param key * @param value *&#x2F; public void put(String key, Object value) &#123; try &#123; w.lock(); System.out.println(Thread.currentThread().getName() + &quot;写操作开始执行......&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; map.put(key, value); &#125; finally &#123; w.unlock(); System.out.println(Thread.currentThread().getName() + &quot;写操作执行完成......&quot;); &#125; &#125; public static void main(String[] args) &#123; final ReadWriteLockDemo d &#x3D; new ReadWriteLockDemo(); d.put(&quot;key1&quot;, &quot;value1&quot;); new Thread(new Runnable() &#123; public void run() &#123; d.get(&quot;key1&quot;); &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; d.get(&quot;key1&quot;); &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; d.get(&quot;key1&quot;); &#125; &#125;).start(); &#125;&#125; 注意：写操作为独占锁，执行期间不能读；读操作可以重复读 4.Volatile关键字4.1作用一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 12341.了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）2.进行指令重排序。（保证变量所在行的有序性）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 4.2.应用场景 基于volatile的作用，使用volatile必须满足以下两个条件： 121.量的写操作不依赖于当前值2.量没有包含在具有其他变量的不变式中常见应用场景如下：状态量标记： 123456789volatile boolean flag &#x3D; false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag &#x3D; true;&#125; 12345678910volatile boolean inited &#x3D; false;&#x2F;&#x2F;线程1:context &#x3D; loadContext(); inited &#x3D; true; &#x2F;&#x2F;线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context); 双重校验： 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance &#x3D; null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance&#x3D;&#x3D;null) &#123; synchronized (Singleton.class) &#123; if(instance&#x3D;&#x3D;null) instance &#x3D; new Singleton(); &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"多线程","slug":"多线程","permalink":"http://pxichen.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://pxichen.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"keywords":[{"name":"多线程","slug":"多线程","permalink":"http://pxichen.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Docker容器安装镜像文件（Tomcat，Mysql）","slug":"Docker容器安装T镜像文件（Tomcat，Mysql）","date":"2019-12-12T01:53:56.000Z","updated":"2019-12-16T05:47:16.574Z","comments":true,"path":"2019/12/12/Docker容器安装T镜像文件（Tomcat，Mysql）/","link":"","permalink":"http://pxichen.github.io/2019/12/12/Docker%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85T%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%EF%BC%88Tomcat%EF%BC%8CMysql%EF%BC%89/","excerpt":"","text":"1、Dockedr简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker守护进程(daemon)： 一般在宿主主机后台运行，等待接收来自客户端的消息。 docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止。 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare（教程使用）、VirtualBox； ​ 2）、导入虚拟机文件centos7.ova； ​ （1）、首先点击“打开虚拟机： ​ （2）、选择虚拟机文件centos7.ova后点击“打开”: ​ （3）、新虚拟机名称和存储路径可以自行修改，点击“导入”： ​ （4）、系统可能会跳出错误提示，直接点击“重试，等待导入完成： ​ （5）、导入成功后，选择该虚拟机，点击菜单栏的”编辑“–”虚拟网络编辑器“： ​ （6）、选择VMNET0–桥接模式–选择当前电脑连接互联网使用的网卡后点击”确定“： ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、查看linux的ip地址 1$ ip addr ​ 8）、使用客户端连接linux(SecureCRT)； &nbsp;下载地址&nbsp;点我下载 ​ （1）、输入主机名（ip地址）用户名(root)后点击”连接“： ​ （2）、点击”接受并保存“： ​ （3）、输入密码123456： 2）、在linux虚拟机上安装dockerDocker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。 社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。 社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。 安装步骤： ​ 1、Docker 要求 CentOS 系统的内核版本高于 3.10 。 通过 uname -r 命令查看当前的内核版本 1[root@localhost ~]#uname -r ​ ​ 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 1[root@localhost ~]#sudo yum update ​ 3、卸载旧版本(如果安装过旧版本的话) 1[root@localhost ~]#sudo yum remove docker docker-common docker-selinux docker-engine ​ 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1[root@localhost ~]#sudo yum install -y yum-utils device-mapper-persistent-data lvm2 ​ 5、设置yum源 12345[root@localhost ~]#sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo这个源是国外网站的，有可能会很慢，可以改成阿里云提供的镜像，二者执行一个即可：[root@localhost ~]#sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo ​ 6、可以查看所有仓库中所有docker版本，并选择特定版本安装 1[root@localhost ~]#yum list docker-ce --showduplicates | sort -r ​ 7、安装docker 12[root@localhost ~]#sudo yum install docker-ce #这里安装的是最新稳定版18.09.6[root@localhost ~]#sudo yum install &lt;FQPN&gt; # 例如：sudo yum install docker-ce-17.12.1.ce ​ 8、启动并加入开机启动 12[root@localhost ~]#sudo systemctl start docker[root@localhost ~]#sudo systemctl enable docker ​ 9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) 1[root@localhost ~]#docker version ​ 10、停止docker 1[root@localhost ~]#sudo systemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作 软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 12345678910111213141516171819202122232425262728 1、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、查看运行中的容器[root@localhost ~]# docker ps 5、停止运行中的容器[root@localhost ~]# docker stop 容器的id6、查看所有的容器[root@localhost ~]# docker ps -a7、启动容器[root@localhost ~]# docker start 容器id8、删除一个容器[root@localhost ~]# docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 更多命令参看 https://docs.docker.com/engine/reference/commandline/docker/ 可以参考每一个镜像的文档 ### 3）、安装MySQL示例 1docker pull mysql 错误的启动 12345678910111213[root@localhost ~]# docker run --name mysql01 -d mysqlf077e80f0b5463d7680413c91bf11265e3ad2b6e66f932977535057fc517381amysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf077e80f0b54 mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01//错误日志[root@localhost ~]# docker logs f077e80f0b54error: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4d177d6518a6 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb931bbc89831306645910006ef55407d85ead7f0db763778240529f9d3cfc578[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb931bbc89831 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02","categories":[{"name":"Docker","slug":"Docker","permalink":"http://pxichen.github.io/categories/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://pxichen.github.io/tags/docker/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"http://pxichen.github.io/categories/Docker/"}]}]}