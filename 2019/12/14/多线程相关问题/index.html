<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="陈显鹏个人博客"><meta name="keywords" content="关键字，java爱好者"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>多线程相关问题 | 人间失格</title><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">多线程相关问题</h1><a id="logo" href="/.">人间失格</a><p class="description">Pain is inevitable. Suffering is optional. 痛苦不可避免，但可以选择是否受苦。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">多线程相关问题</h1><div class="post-meta"><a href="/2019/12/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/#comments" class="comment-count"></a><p><span class="date">Dec 14, 2019</span><span><a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="category">多线程</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一-目录"><a href="#一-目录" class="headerlink" title="一. 目录"></a>一. 目录</h2><ul>
<li>什么是并发与并行</li>
<li>什么是进程与线程</li>
<li>线程生命周期</li>
<li>线程安全问题</li>
<li>什么是线程安全问题</li>
<li>线程安全问题解决方案</li>
<li>线程死锁</li>
<li>线程通信</li>
<li>线程特性</li>
<li>多线程控制</li>
<li>线程池</li>
</ul>
<h2 id="二-什么是并发与并行"><a href="#二-什么是并发与并行" class="headerlink" title="二.什么是并发与并行"></a>二.什么是并发与并行</h2><p>创建多线程是为了解决高并发问题的，所以我们要先了解什么是并发与并行</p>
<ul>
<li>并行：多个处理器或多核处理器同时处理多个任务。</li>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li>
</ul>
<p><img src="/images/pasted-6.png" alt=""></p>
<h2 id="三-什么是进程与线程"><a href="#三-什么是进程与线程" class="headerlink" title="三.什么是进程与线程"></a>三.什么是进程与线程</h2><p>进程：</p>
<ul>
<li>进程是正在运行的程序的实例。</li>
<li>进程是线程的容器，即一个进程中可以开启多个线程。</li>
<li>比如打开一个浏览器、打开一个word等操作，都会创建进程。<br><img src="/images/pasted-7.png" alt=""></li>
</ul>
<p>线程：</p>
<ul>
<li>线程是进程内部的一个独立执行单元；</li>
<li>一个进程可以同时并发运行多个线程；</li>
<li>比如进程可以理解为医院，线程是挂号、就诊、缴费、拿药等业务活动</li>
</ul>
<p><img src="/images/pasted-8.png" alt=""></p>
<p>多线程：多个线程并发执行</p>
<h2 id="四-线程创建"><a href="#四-线程创建" class="headerlink" title="四.线程创建"></a>四.线程创建</h2><p>Java中线程有四种创建方式：</p>
<pre><code>继承Thread类
实现Runnable接口
实现Callable接口
线程池</code></pre><h5 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.    继承Thread类"></a>1.    继承Thread类</h5><p>  1.1创建自定义线程类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;mythread线程正在执行：&quot;+new Date().getTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.2 创建测试类</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    public class ThreadCreateDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建自定义线程</span><br><span class="line">        MyThread thread &#x3D; new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        &#x2F;&#x2F;2.主线程循环打印</span><br><span class="line">        for (int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;main主线程正在执行：&quot;+new Date().getTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h5><p>   2.1 创建自定义类实现Runnable接口</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    public class MyRunable implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;MyRunnable线程正在执行：&quot;+new Date().getTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   2.2 创建测试类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    public class ThreadCreateDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建自定义线程</span><br><span class="line">        Thread thread &#x3D; new Thread(new MyRunable());</span><br><span class="line">        thread.start();</span><br><span class="line">        &#x2F;&#x2F;2.主线程循环打印</span><br><span class="line">        for (int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;main主线程正在执行：&quot;+new Date().getTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h5><p>3.1 创建自定义类实现Callable接口</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   public class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        for (int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;MyCallable正在执行：&quot;+new Date().getTime());</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;MyCallable执行完毕！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   3.2 创建测试类</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   public class ThreadCreateDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask task &#x3D; new FutureTask(new MyCallable());</span><br><span class="line">        Thread thread &#x3D; new Thread(task);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        for (int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;main主线程正在执行：&quot;+new Date().getTime());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-线程池-Executor"><a href="#4-线程池-Executor" class="headerlink" title="4. 线程池-Executor"></a>4. 线程池-Executor</h5><p>4.1创建自定义类实现Runnable接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunable implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;MyRunnable线程正在执行：&quot;+new Date().getTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>   4,2创建测试类</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    public class ThreadCreateDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.使用Executors创建线程池</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">        &#x2F;&#x2F;2.通过线程池执行线程</span><br><span class="line">        executorService.execute(new MyRunable());</span><br><span class="line">        &#x2F;&#x2F;3.主线程循环打印</span><br><span class="line">        for (int i&#x3D;0; i&lt;10; i++)&#123;</span><br><span class="line">            System.out.println(&quot;main主线程正在执行：&quot;+new Date().getTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>各种方式比较</p>
<p> 5.1    实现接口和继承Thread类比较</p>
<ul>
<li>接口更适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>接口可以避免java中的单继承的局限性。</li>
<li>接口代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable接口的线程，不能直接放入继承Thread的类。</li>
</ul>
<p>5.2    Runnable和Callable接口比较</p>
<p> 相同点：</p>
<ul>
<li><p>两者都是接口；</p>
</li>
<li><p>两者都可用来编写多线程程序；</p>
</li>
<li><p>两者都需要调用Thread.start()启动线程；</p>
<p>不同点：</p>
</li>
<li><p>实现Callable接口的线程能返回执行结果；而实现Runnable接口的线程不能返回结果；</p>
</li>
<li><p>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的不允许抛异常；</p>
</li>
<li><p>实现Callable接口的线程可以调用Future.cancel取消执行 ，而实现Runnable接口的线程不能</p>
<p>注意点：</p>
<p>Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！</p>
</li>
</ul>
</li>
</ol>
<h2 id="五-线程生命周期"><a href="#五-线程生命周期" class="headerlink" title="五.线程生命周期"></a>五.线程生命周期</h2><p>   <img src="/images/pasted-9.png" alt=""></p>
<h5 id="1-新建"><a href="#1-新建" class="headerlink" title="1.新建"></a>1.新建</h5><ul>
<li>new关键字创建了一个线程之后，该线程就处于新建状态</li>
<li>JVM为线程分配内存，初始化成员变量值</li>
</ul>
<h5 id="2-就绪"><a href="#2-就绪" class="headerlink" title="2.就绪"></a>2.就绪</h5><ul>
<li>当线程对象调用了start()方法之后，该线程处于就绪状态</li>
<li>JVM为线程创建方法栈和程序计数器，等待线程调度器调度</li>
</ul>
<h5 id="3-运行"><a href="#3-运行" class="headerlink" title="3.运行"></a>3.运行</h5><ul>
<li>就绪状态的线程获得CPU资源，开始运行run()方法，该线程进入运行状态</li>
</ul>
<h5 id="4-阻塞"><a href="#4-阻塞" class="headerlink" title="4.阻塞"></a>4.阻塞</h5><ul>
<li>线程调用sleep()方法主动放弃所占用的处理器资源</li>
<li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞</li>
<li>线程试图获得一个同步锁（同步监视器），但该同步锁正被其他线程所持有。</li>
<li>线程在等待某个通知（notify）</li>
<li>程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法</li>
</ul>
<h5 id="5-死亡"><a href="#5-死亡" class="headerlink" title="5.死亡"></a>5.死亡</h5><p>   线程会以如下3种方式结束，结束后就处于死亡状态：</p>
<ul>
<li>run()或call()方法执行完成，线程正常结束。</li>
</ul>
<h2 id="六-线程安全问题"><a href="#六-线程安全问题" class="headerlink" title="六.线程安全问题"></a>六.线程安全问题</h2><h5 id="1-什么是线程安全问题？"><a href="#1-什么是线程安全问题？" class="headerlink" title="1. 什么是线程安全问题？"></a>1. 什么是线程安全问题？</h5><p>如果有多个线程同时运行同一个实现了Runnable接口的类，程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的；反之，则是线程不安全的。</p>
<h5 id="2-问题演示"><a href="#2-问题演示" class="headerlink" title="2.问题演示"></a>2.问题演示</h5><p>模拟春节抢购车票。</p>
<h6 id="1-第一步：创建售票线程类"><a href="#1-第一步：创建售票线程类" class="headerlink" title="1.第一步：创建售票线程类"></a>1.第一步：创建售票线程类</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Ticket implements Runnable &#123;</span><br><span class="line">    private int ticktNum &#x3D; 100;</span><br><span class="line">    </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(ticktNum &gt; 0)&#123;</span><br><span class="line">                &#x2F;&#x2F;1.模拟出票时间</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;2.打印进程号和票号，票数减1</span><br><span class="line">                String name &#x3D; Thread.currentThread().getName();</span><br><span class="line">                System.out.println(&quot;线程&quot;+name+&quot;售票：&quot;+ticktNum--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-第二步：创建测试类"><a href="#2-第二步：创建测试类" class="headerlink" title="2.第二步：创建测试类"></a>2.第二步：创建测试类</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TicketDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Ticket ticket &#x3D; new Ticket();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(ticket, &quot;窗口1&quot;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(ticket, &quot;窗口2&quot;);</span><br><span class="line">        Thread thread3 &#x3D; new Thread(ticket, &quot;窗口3&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/images/pasted-10.png" alt=""></p>
<p>程序出现了两个问题：</p>
<ol>
<li>相同的票数,比如5这张票被卖了两回。</li>
<li>不存在的票，比如0票与-1票，是不存在的。</li>
</ol>
<h5 id="3-问题分析"><a href="#3-问题分析" class="headerlink" title="3.问题分析"></a>3.问题分析</h5><ol>
<li>线程安全问题都是由全局变量及静态变量引起的。</li>
<li>若每个线程对全局变量、静态变量只读，不写，一般来说，这个变量是线程安全的；</li>
<li>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li>
</ol>
<p>综上所述，线程安全问题根本原因:</p>
<ul>
<li>线程在操作共享的数据；</li>
<li>共享数据的线程代码有多条；</li>
<li>线程对共享数据有写操作；</li>
</ul>
<h5 id="4-问题解决（线程同步）"><a href="#4-问题解决（线程同步）" class="headerlink" title="4.问题解决（线程同步）"></a>4.问题解决（线程同步）</h5><p>要解决以上线程问题，只要在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p>
<p> 为了保证每个线程都能正常执行共享资源操作,Java引入了7种线程同步机制,主要是是前三种。</p>
<ol>
<li>同步代码块（synchronized）</li>
<li>同步方法（synchronized）</li>
<li>同步锁（ReenreantLock）</li>
<li>特殊域变量（volatile）</li>
<li>局部变量（ThreadLocal）</li>
<li>阻塞队列（LinkedBlockingQueue）</li>
<li>原子变量（Atomic*）</li>
</ol>
<h6 id="4-1-同步代码块（synchronized）"><a href="#4-1-同步代码块（synchronized）" class="headerlink" title="4.1.    同步代码块（synchronized）"></a>4.1.    同步代码块（synchronized）</h6><p>同步代码块 ：</p>
<p>synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步锁:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</span><br><span class="line">	1. 锁对象可以是任意类型。</span><br><span class="line">	2. 多个线程要使用同一把锁。</span><br><span class="line">注意：在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</span><br></pre></td></tr></table></figure>

<p>我们把刚才售票的案例使用同步代码块，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Ticket implements Runnable &#123;</span><br><span class="line">    private int ticktNum &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义锁对象</span><br><span class="line">    Object obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            synchronized (obj)&#123;</span><br><span class="line">                if(ticktNum &gt; 0)&#123;</span><br><span class="line">                    &#x2F;&#x2F;1.模拟出票时间</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;2.打印进程号和票号，票数减1</span><br><span class="line">                    String name &#x3D; Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(&quot;线程&quot;+name+&quot;售票：&quot;+ticktNum--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 执行结果如下：</p>
<p><img src="/images/pasted-11.png" alt=""></p>
<h6 id="4-2-同步方法（synchronized）"><a href="#4-2-同步方法（synchronized）" class="headerlink" title="4.2    同步方法（synchronized）"></a>4.2    同步方法（synchronized）</h6><p>同步方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</span><br></pre></td></tr></table></figure>

<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()&#123;</span><br><span class="line">   可能会产生线程安全问题的代码 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 同步锁是谁?<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对于非static方法,同步锁就是this。</span><br><span class="line">2.对于static方法,同步锁是当前方法所在类的字节码对象(类名.class)。</span><br></pre></td></tr></table></figure><br>把售票的案例使用同步方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Ticket implements Runnable &#123;</span><br><span class="line">    private int ticktNum &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义锁对象</span><br><span class="line">    Object obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized void sellTicket()&#123;</span><br><span class="line">        if(ticktNum &gt; 0)&#123;</span><br><span class="line">            &#x2F;&#x2F;1.模拟出票时间</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;2.打印进程号和票号，票数减1</span><br><span class="line">            String name &#x3D; Thread.currentThread().getName();</span><br><span class="line">            System.out.println(&quot;线程&quot;+name+&quot;售票：&quot;+ticktNum--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 执行结果如下：</p>
<p><img src="/images/pasted-11.png" alt=""></p>
<h6 id="4-3-同步锁（ReenreantLock）"><a href="#4-3-同步锁（ReenreantLock）" class="headerlink" title="4.3 同步锁（ReenreantLock）"></a>4.3 同步锁（ReenreantLock）</h6><p>同步锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作，同步代码块&#x2F;同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</span><br></pre></td></tr></table></figure>
<p>同步锁方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void lock() :加同步锁。</span><br><span class="line">public void unlock() :释放同步锁。</span><br></pre></td></tr></table></figure>
<p>把开始的案例使用重入锁代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Ticket implements Runnable &#123;</span><br><span class="line">    private int ticktNum &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义锁对象：构造函数参数为线程是否公平获取锁true-公平；false-不公平，即由某个线程独占，默认是false</span><br><span class="line">    Lock lock &#x3D; new ReentrantLock(true);</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try&#123;</span><br><span class="line">                &#x2F;&#x2F;加锁</span><br><span class="line">                if(ticktNum &gt; 0)&#123;</span><br><span class="line">                    &#x2F;&#x2F;1.模拟出票时间</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(50);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;2.打印进程号和票号，票数减1</span><br><span class="line">                    String name &#x3D; Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(&quot;线程&quot;+name+&quot;售票：&quot;+ticktNum--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F;放锁</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 执行结果如下：</p>
<p><img src="/images/pasted-11.png" alt=""></p>
<h5 id="5-Synchronized和Lock区别"><a href="#5-Synchronized和Lock区别" class="headerlink" title="5.Synchronized和Lock区别"></a>5.Synchronized和Lock区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class="line">2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class="line">3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class="line">4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class="line">5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</span><br><span class="line">6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure>

<h2 id="七-线程死锁"><a href="#七-线程死锁" class="headerlink" title="七.线程死锁"></a>七.线程死锁</h2><h5 id="1-什么是死锁？"><a href="#1-什么是死锁？" class="headerlink" title="1.什么是死锁？"></a>1.什么是死锁？</h5><p>多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力。然而，并发执行也带来了新的问题–死锁。</p>
<p>所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。<br><img src="/images/pasted-12.png" alt=""></p>
<h5 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2.死锁产生的必要条件"></a>2.死锁产生的必要条件</h5><p>以下这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.互斥条件</span><br><span class="line">进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</span><br><span class="line">2.不可剥夺条件</span><br><span class="line">进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</span><br><span class="line">3.请求与保持条件</span><br><span class="line">进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</span><br><span class="line">4.循环等待条件</span><br><span class="line">存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合&#123;Pl, P2, …, pn&#125;，其中Pi等 待的资源被P(i+1)占有（i&#x3D;0, 1, …, n-1)，Pn等待的资源被P0占有，如图所示。</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-13.png" alt=""></p>
<h5 id="3-死锁代码试例"><a href="#3-死锁代码试例" class="headerlink" title="3.死锁代码试例"></a>3.死锁代码试例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLock implements Runnable &#123;</span><br><span class="line">    private static Object obj1 &#x3D; new Object();&#x2F;&#x2F;定义成静态变量，使线程可以共享实例</span><br><span class="line">    private static Object obj2 &#x3D; new Object();&#x2F;&#x2F;定义成静态变量，使线程可以共享实例</span><br><span class="line">    public int flag &#x3D; 0;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if(flag &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            System.out.println(&quot;flag：&quot;+flag);</span><br><span class="line">            synchronized (obj1)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (obj2)&#123;</span><br><span class="line">                    System.out.println(&quot;flag：&quot;+flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            System.out.println(&quot;flag：&quot;+flag);</span><br><span class="line">            synchronized (obj2)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (obj1)&#123;</span><br><span class="line">                    System.out.println(&quot;flag：&quot;+flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DeadLock deadLock1 &#x3D; new DeadLock();</span><br><span class="line">        DeadLock deadLock2 &#x3D; new DeadLock();</span><br><span class="line">        deadLock2.flag &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        Thread thread1 &#x3D; new Thread(deadLock1);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(deadLock2);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：只打印两个flag值，表示死锁产生</p>
<h5 id="4-死锁处理"><a href="#4-死锁处理" class="headerlink" title="4.死锁处理"></a>4.死锁处理</h5><ul>
<li>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。</li>
<li>避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。</li>
<li>检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。</li>
<li>解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。</li>
</ul>
<h5 id="5-死锁预防"><a href="#5-死锁预防" class="headerlink" title="5.死锁预防"></a>5.死锁预防</h5><p>预防死锁是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现。</p>
<h6 id="5-1-破坏“互斥”条件"><a href="#5-1-破坏“互斥”条件" class="headerlink" title="5.1 破坏“互斥”条件"></a>5.1 破坏“互斥”条件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。</span><br></pre></td></tr></table></figure>
<h5 id="5-2-破坏“占有并等待”条件"><a href="#5-2-破坏“占有并等待”条件" class="headerlink" title="5.2 破坏“占有并等待”条件"></a>5.2 破坏“占有并等待”条件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。</span><br><span class="line">方法一：</span><br><span class="line">一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。</span><br><span class="line">方法二：</span><br><span class="line">要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。</span><br></pre></td></tr></table></figure>
<h5 id="5-3-破坏“不可抢占”条件"><a href="#5-3-破坏“不可抢占”条件" class="headerlink" title="5.3 破坏“不可抢占”条件"></a>5.3 破坏“不可抢占”条件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">破坏“不可抢占”条件就是允许对资源实行抢夺。</span><br><span class="line">方法一：</span><br><span class="line">如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。</span><br><span class="line">方法二：</span><br><span class="line">如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。</span><br></pre></td></tr></table></figure>
<h5 id="5-4-破坏“循环等待”条件"><a href="#5-4-破坏“循环等待”条件" class="headerlink" title="5.4 破坏“循环等待”条件"></a>5.4 破坏“循环等待”条件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</span><br></pre></td></tr></table></figure>

<h5 id="6-死锁避免"><a href="#6-死锁避免" class="headerlink" title="6.死锁避免"></a>6.死锁避免</h5><p>避免死锁不严格限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。</p>
<h5 id="6-1-有序资源分配法"><a href="#6-1-有序资源分配法" class="headerlink" title="6.1 有序资源分配法"></a>6.1 有序资源分配法</h5><p>该算法实现步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.必须为所有资源统一编号，例如打印机为1、传真机为2、磁盘为3等</span><br><span class="line">2.同类资源必须一次申请完，例如打印机和传真机一般为同一个机器，必须同时申请</span><br><span class="line">3.不同类资源必须按顺序申请</span><br><span class="line">例如：有两个进程P1和P2，有两个资源R1和R2</span><br><span class="line">P1请求资源：R1、R2</span><br><span class="line">P2请求资源：R1、R2</span><br><span class="line">这样就破坏了环路条件，避免了死锁的发生。</span><br></pre></td></tr></table></figure>

<h5 id="6-2-银行家算法"><a href="#6-2-银行家算法" class="headerlink" title="6.2 银行家算法"></a>6.2 银行家算法</h5><p>银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格•迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。流程图如下：<br><img src="/images/pasted-14.png" alt=""><br>银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设进程i提出请求REQUEST [i]，则银行家算法按如下规则进行判断。</span><br><span class="line">1.	如果REQUEST [i]&lt;&#x3D; NEED[i，j]，则转（2)；否则，出错。</span><br><span class="line">2.	如果REQUEST [i]&lt;&#x3D; AVAILABLE[i]，则转（3)；否则，等待。</span><br><span class="line">3.	系统试探分配资源，修改相关数据：</span><br><span class="line">AVAILABLE[i]-&#x3D;REQUEST[i];&#x2F;&#x2F;可用资源数-请求资源数</span><br><span class="line">ALLOCATION[i]+&#x3D;REQUEST[i];&#x2F;&#x2F;已分配资源数+请求资源数</span><br><span class="line">NEED[i]-&#x3D;REQUEST[i];&#x2F;&#x2F;需要资源数-请求资源数</span><br><span class="line">4.	系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。</span><br></pre></td></tr></table></figure>
<h5 id="6-3-顺序加锁"><a href="#6-3-顺序加锁" class="headerlink" title="6.3 顺序加锁"></a>6.3 顺序加锁</h5><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如以下两个线程就会死锁：</span><br><span class="line">Thread 1:</span><br><span class="line">lock A (when C locked) </span><br><span class="line">lock B (when C locked) </span><br><span class="line">wait for C</span><br><span class="line">Thread 2: </span><br><span class="line">wait for A </span><br><span class="line">wait for B</span><br><span class="line">lock C (when A locked)</span><br></pre></td></tr></table></figure>
<p>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。    例如以下两个线程就不会死锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: </span><br><span class="line">lock A </span><br><span class="line">lock B</span><br><span class="line">lock C</span><br><span class="line">Thread 2: </span><br><span class="line">wait for A </span><br><span class="line">wait for B</span><br><span class="line">wait for C</span><br></pre></td></tr></table></figure>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景。</p>
<h5 id="6-4-限时加锁"><a href="#6-4-限时加锁" class="headerlink" title="6.4 限时加锁"></a>6.4 限时加锁</h5><p>限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试</p>
<p>以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 locks A </span><br><span class="line">Thread 2 locks B </span><br><span class="line">Thread 1 attempts to lock B but is blocked </span><br><span class="line">Thread 2 attempts to lock A but is blocked </span><br><span class="line">Thread 1’s lock attempt on B times out </span><br><span class="line">Thread 1 backs up and releases A as well </span><br><span class="line">Thread 1 waits randomly (e.g. 257 millis) before retrying. </span><br><span class="line">Thread 2’s lock attempt on A times out </span><br><span class="line">Thread 2 backs up and releases B as well </span><br><span class="line">Thread 2 waits randomly (e.g. 43 millis) before retrying.</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁。</p>
<p>这种方式有两个缺点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。</span><br><span class="line">2,Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。</span><br></pre></td></tr></table></figure>
<h5 id="6-5-死锁检测"><a href="#6-5-死锁检测" class="headerlink" title="6.5    死锁检测"></a>6.5    死锁检测</h5><p>预防和避免死锁系统开销大且不能充分利用资源，更好的方法是不采取任何限制性措施，而是提供检测和解脱死锁的手段，这就是死锁检测和恢复。</p>
<p>死锁检测数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.E是现有资源向量（existing resource vector），代码每种已存在资源的总数</span><br><span class="line">2.A是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）</span><br><span class="line">3.C是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数</span><br><span class="line">4.R是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-15.png" alt=""></p>
<p>死锁检测步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。</span><br><span class="line">2.如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步</span><br><span class="line">3.如果没有这样的进程，那么算法终止</span><br><span class="line">4.算法结束时，所有没有标记过的进程都是死锁进程。</span><br></pre></td></tr></table></figure>
<h5 id="6-6死锁恢复"><a href="#6-6死锁恢复" class="headerlink" title="6.6死锁恢复"></a>6.6死锁恢复</h5><p>利用抢占恢复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时将某个资源从它的当前所属进程转移到另一个进程。</span><br><span class="line">这种做法很可能需要人工干预，主要做法是否可行需取决于资源本身的特性。</span><br></pre></td></tr></table></figure>
<p>利用回滚恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">周期性的将进程的状态进行备份，当发现进程死锁后，根据备份将该进程复位到一个更早的，还没有取得所需的资源的状态，接着就把这些资源分配给其他死锁进程。</span><br></pre></td></tr></table></figure>
<p>通过杀死进程恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最直接简单的方式就是杀死一个或若干个进程。</span><br><span class="line">尽可能保证杀死的进程可以从头再来而不带来副作用。</span><br></pre></td></tr></table></figure>

<h2 id="七-线程通信"><a href="#七-线程通信" class="headerlink" title="七.线程通信"></a>七.线程通信</h2><h5 id="1-为什么要线程通信"><a href="#1-为什么要线程通信" class="headerlink" title="1.为什么要线程通信"></a>1.为什么要线程通信</h5><p>多个线程并发执行时，在默认情况下CPU是随机切换线程的，有时我们希望CPU按我们的规律执行线程，此时就需要线程之间协调通信。</p>
<h5 id="2-线程通信的方式"><a href="#2-线程通信的方式" class="headerlink" title="2.线程通信的方式"></a>2.线程通信的方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.休眠唤醒方式：</span><br><span class="line">Object的wait、notify、notifyAll</span><br><span class="line">Condition的await、signal、signalAll</span><br><span class="line">2.CountDownLatch：用于某个线程A等待若干个其他线程执行完之后，它才执行</span><br><span class="line">3.CyclicBarrier：一组线程等待至某个状态之后再全部同时执行</span><br><span class="line">4.Semaphore：用于控制对某组资源的访问权限</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
<h6 id="2-1-休眠唤醒方式"><a href="#2-1-休眠唤醒方式" class="headerlink" title="2.1 休眠唤醒方式"></a>2.1 休眠唤醒方式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object和Condition休眠唤醒区别:</span><br><span class="line">1.object wait()必须在synchronized（同步锁）下使用， </span><br><span class="line">2.object wait()必须要通过Nodify()方法进行唤醒 </span><br><span class="line">3.condition await() 必须和Lock（互斥锁&#x2F;共享锁）配合使用</span><br><span class="line">4.condition await() 必须通过 signal() 方法进行唤醒</span><br></pre></td></tr></table></figure>
<h6 id="2-2-CountDownLatch方式"><a href="#2-2-CountDownLatch方式" class="headerlink" title="2.2 CountDownLatch方式"></a>2.2 CountDownLatch方式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch是在java1.5被引入的，存在于java.util.concurrent包下。</span><br><span class="line">CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。</span><br><span class="line">CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-16.png" alt=""></p>
<p>每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>
<h6 id="2-3-CyclicBarrier方式"><a href="#2-3-CyclicBarrier方式" class="headerlink" title="2.3 CyclicBarrier方式"></a>2.3 CyclicBarrier方式</h6><p>CyclicBarrier是在java1.5被引入的，存在于java.util.concurrent包下。<br>CyclicBarrier实现让一组线程等待至某个状态之后再全部同时执行。<br>CyclicBarrier底层是<br>三个线程同时启动.</p>
<h6 id="2-4-Semaphore方式"><a href="#2-4-Semaphore方式" class="headerlink" title="2.4 Semaphore方式"></a>2.4 Semaphore方式</h6><p>Semaphore是在java1.5被引入的，存在于java.util.concurrent包下。<br>Semaphore用于控制对某组资源的访问权限。</p>
<h5 id="3-wait和sleep有什么区别？"><a href="#3-wait和sleep有什么区别？" class="headerlink" title="3.wait和sleep有什么区别？"></a>3.wait和sleep有什么区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">•类的不同：sleep() 来自 Thread，wait() 来自 Object。</span><br><span class="line">•释放锁：sleep() 不释放锁；wait() 释放锁。</span><br><span class="line">•用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()&#x2F;notifyAll()直接唤醒。</span><br></pre></td></tr></table></figure>
<h5 id="4-notify和notifyAll有什么区别？"><a href="#4-notify和notifyAll有什么区别？" class="headerlink" title="4.notify和notifyAll有什么区别？"></a>4.notify和notifyAll有什么区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</span><br></pre></td></tr></table></figure>
<h5 id="5-wait和notify区别"><a href="#5-wait和notify区别" class="headerlink" title="5.wait和notify区别"></a>5.wait和notify区别</h5><p><img src="/images/pasted-17.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">都是Object中的方法</span><br><span class="line">wait和notify执行前线程都必须获得对象锁</span><br><span class="line">wait的作用是使当前线程进行等待</span><br><span class="line">notify的作用是通知其他等待当前线程的对象锁的线程</span><br></pre></td></tr></table></figure>

<h2 id="八-线程特性"><a href="#八-线程特性" class="headerlink" title="八.线程特性"></a>八.线程特性</h2><p>多线程编程要保证满足三个特性：原子性、可见性、有序性。</p>
<h5 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h5><p>原子性，即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<h5 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h5><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。显然，对于单线程来说，可见性问题是不存在的。</p>
<h5 id="1-有序性"><a href="#1-有序性" class="headerlink" title="1.有序性"></a>1.有序性</h5><p>有序性即程序执行的顺序按照代码的先后顺序执行。</p>
<h2 id="九-多线程控制类"><a href="#九-多线程控制类" class="headerlink" title="九.多线程控制类"></a>九.多线程控制类</h2><p>为了保证多线程的三个特性，Java引入了很多线程控制机制，下面是其中常用的几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal</span><br><span class="line">原子类</span><br><span class="line">Lock类</span><br><span class="line">Volatile关键字</span><br></pre></td></tr></table></figure>
<h5 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1.ThreadLocal"></a>1.ThreadLocal</h5><p>ThreadLocal提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。<br>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal，比如数据库连接Connection，每个请求处理线程都需要，但又不相互影响，就是用ThreadLocal实现。</p>
<h5 id="2-原子类"><a href="#2-原子类" class="headerlink" title="2.原子类"></a>2.原子类</h5><p>Java的java.util.concurrent.atomic包里面提供了很多可以进行原子操作的类，分为以下四类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong</span><br><span class="line">原子更新数组：AtomicIntegerArray、AtomicLongArray</span><br><span class="line">原子更新引用：AtomicReference、AtomicStampedReference等</span><br><span class="line">原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</span><br></pre></td></tr></table></figure>
<p>提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。</p>
<h5 id="3-Lock类"><a href="#3-Lock类" class="headerlink" title="3.Lock类"></a>3.Lock类</h5><h6 id="3-1-Lock接口关系图"><a href="#3-1-Lock接口关系图" class="headerlink" title="3.1 Lock接口关系图"></a>3.1 Lock接口关系图</h6><p><img src="/images/pasted-18.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lock和ReadWriteLock是两大锁的根接口</span><br><span class="line">Lock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。</span><br><span class="line">ReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。</span><br></pre></td></tr></table></figure>
<h6 id="3-2-可重入锁"><a href="#3-2-可重入锁" class="headerlink" title="3.2 可重入锁"></a>3.2 可重入锁</h6><p>不可重入锁，即线程请求它已经拥有的锁时会阻塞。<br>可重入锁，即线程可以进入它已经拥有的锁的同步代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;3;i++)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-3-读写锁"><a href="#3-3-读写锁" class="headerlink" title="3.3 读写锁"></a>3.3 读写锁</h6><p>读写锁，即可以同时读，读的时候不能写；不能同时写，写的时候不能读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.multithread.thread;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 读写操作类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">    &#x2F;&#x2F;创建一个读写锁实例</span><br><span class="line">    private ReadWriteLock rw &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    &#x2F;&#x2F;创建一个读锁</span><br><span class="line">    private Lock r &#x3D; rw.readLock();</span><br><span class="line">    &#x2F;&#x2F;创建一个写锁</span><br><span class="line">    private Lock w &#x3D; rw.writeLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 读操作</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object get(String key) &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;读操作开始执行......&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;读操作执行完成......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 写操作</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void put(String key, Object value) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;写操作开始执行......&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;写操作执行完成......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final ReadWriteLockDemo d &#x3D; new ReadWriteLockDemo();</span><br><span class="line">        d.put(&quot;key1&quot;, &quot;value1&quot;);</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                d.get(&quot;key1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                d.get(&quot;key1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                d.get(&quot;key1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：写操作为独占锁，执行期间不能读；读操作可以重复读</p>
<h5 id="4-Volatile关键字"><a href="#4-Volatile关键字" class="headerlink" title="4.Volatile关键字"></a>4.Volatile关键字</h5><h6 id="4-1作用"><a href="#4-1作用" class="headerlink" title="4.1作用"></a>4.1作用</h6><p>一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）</span><br><span class="line">2.进行指令重排序。（保证变量所在行的有序性）</span><br><span class="line">当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</span><br><span class="line">在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</span><br></pre></td></tr></table></figure>
<h5 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2.应用场景"></a>4.2.应用场景</h5><p> 基于volatile的作用，使用volatile必须满足以下两个条件：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.量的写操作不依赖于当前值</span><br><span class="line">2.量没有包含在具有其他变量的不变式中</span><br></pre></td></tr></table></figure><br>常见应用场景如下：<br>状态量标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean flag &#x3D; false;</span><br><span class="line"> </span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean inited &#x3D; false;</span><br><span class="line">&#x2F;&#x2F;线程1:</span><br><span class="line">context &#x3D; loadContext();  </span><br><span class="line">inited &#x3D; true;            </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>双重校验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance &#x3D; null;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance&#x3D;&#x3D;null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance&#x3D;&#x3D;null)</span><br><span class="line">                    instance &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><blockquote><p>原文作者: Pxichen</p><p>原文链接: <a href="http://pxichen.github.io/2019/12/14/多线程相关问题/">http://pxichen.github.io/2019/12/14/多线程相关问题/</a></p><p>版权声明: 转载请说明出处（必须保留原文作者署名链接）</p></blockquote></div><div class="tags"><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到:</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/12/14/%E7%8E%A9%E8%BD%ACBootstrap%E6%A1%86%E6%9E%B6/" class="pre">玩转Bootstrap框架</a><a href="/2019/12/12/Docker%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85T%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%EF%BC%88Tomcat%EF%BC%8CMysql%EF%BC%89/" class="next">Docker容器安装镜像文件（Tomcat，Mysql）</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NzkxMi8yNDQwOQ=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-目录"><span class="toc-text">一. 目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-什么是并发与并行"><span class="toc-text">二.什么是并发与并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-什么是进程与线程"><span class="toc-text">三.什么是进程与线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-线程创建"><span class="toc-text">四.线程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-继承Thread类"><span class="toc-text">1.    继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-实现Runnable接口"><span class="toc-text">2. 实现Runnable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-实现Callable接口"><span class="toc-text">3. 实现Callable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-线程池-Executor"><span class="toc-text">4. 线程池-Executor</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-线程生命周期"><span class="toc-text">五.线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-新建"><span class="toc-text">1.新建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-就绪"><span class="toc-text">2.就绪</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-运行"><span class="toc-text">3.运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-阻塞"><span class="toc-text">4.阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-死亡"><span class="toc-text">5.死亡</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-线程安全问题"><span class="toc-text">六.线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-什么是线程安全问题？"><span class="toc-text">1. 什么是线程安全问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-问题演示"><span class="toc-text">2.问题演示</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-第一步：创建售票线程类"><span class="toc-text">1.第一步：创建售票线程类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-第二步：创建测试类"><span class="toc-text">2.第二步：创建测试类</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-问题分析"><span class="toc-text">3.问题分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-问题解决（线程同步）"><span class="toc-text">4.问题解决（线程同步）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1-同步代码块（synchronized）"><span class="toc-text">4.1.    同步代码块（synchronized）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2-同步方法（synchronized）"><span class="toc-text">4.2    同步方法（synchronized）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-3-同步锁（ReenreantLock）"><span class="toc-text">4.3 同步锁（ReenreantLock）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Synchronized和Lock区别"><span class="toc-text">5.Synchronized和Lock区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-线程死锁"><span class="toc-text">七.线程死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-什么是死锁？"><span class="toc-text">1.什么是死锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-死锁产生的必要条件"><span class="toc-text">2.死锁产生的必要条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-死锁代码试例"><span class="toc-text">3.死锁代码试例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-死锁处理"><span class="toc-text">4.死锁处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-死锁预防"><span class="toc-text">5.死锁预防</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#5-1-破坏“互斥”条件"><span class="toc-text">5.1 破坏“互斥”条件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-破坏“占有并等待”条件"><span class="toc-text">5.2 破坏“占有并等待”条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-破坏“不可抢占”条件"><span class="toc-text">5.3 破坏“不可抢占”条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-破坏“循环等待”条件"><span class="toc-text">5.4 破坏“循环等待”条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-死锁避免"><span class="toc-text">6.死锁避免</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-有序资源分配法"><span class="toc-text">6.1 有序资源分配法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-银行家算法"><span class="toc-text">6.2 银行家算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-顺序加锁"><span class="toc-text">6.3 顺序加锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-限时加锁"><span class="toc-text">6.4 限时加锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-死锁检测"><span class="toc-text">6.5    死锁检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6死锁恢复"><span class="toc-text">6.6死锁恢复</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-线程通信"><span class="toc-text">七.线程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-为什么要线程通信"><span class="toc-text">1.为什么要线程通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-线程通信的方式"><span class="toc-text">2.线程通信的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-休眠唤醒方式"><span class="toc-text">2.1 休眠唤醒方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-CountDownLatch方式"><span class="toc-text">2.2 CountDownLatch方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-CyclicBarrier方式"><span class="toc-text">2.3 CyclicBarrier方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-Semaphore方式"><span class="toc-text">2.4 Semaphore方式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-wait和sleep有什么区别？"><span class="toc-text">3.wait和sleep有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-notify和notifyAll有什么区别？"><span class="toc-text">4.notify和notifyAll有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-wait和notify区别"><span class="toc-text">5.wait和notify区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-线程特性"><span class="toc-text">八.线程特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-原子性"><span class="toc-text">1.原子性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-可见性"><span class="toc-text">1.可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-有序性"><span class="toc-text">1.有序性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-多线程控制类"><span class="toc-text">九.多线程控制类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ThreadLocal"><span class="toc-text">1.ThreadLocal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-原子类"><span class="toc-text">2.原子类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Lock类"><span class="toc-text">3.Lock类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1-Lock接口关系图"><span class="toc-text">3.1 Lock接口关系图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-可重入锁"><span class="toc-text">3.2 可重入锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-读写锁"><span class="toc-text">3.3 读写锁</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Volatile关键字"><span class="toc-text">4.Volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1作用"><span class="toc-text">4.1作用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-应用场景"><span class="toc-text">4.2.应用场景</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/24/SpringBoot%E6%95%B4%E5%90%88%E7%BC%93%E5%AD%98%EF%BC%88Cache%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%EF%BC%89/">SpringBoot整合缓存（Cache的详细使用）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/18/Mybatis%E5%8A%A8%E6%80%81SQL%E4%B8%ADtrim%E6%A0%87%E7%AD%BE%E7%9A%84%E7%94%A8%E6%B3%95/">Mybatis动态SQL中trim标签的用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/15/Maven%E6%90%AD%E5%BB%BAssm%E9%A1%B9%E7%9B%AE/">Maven搭建ssm项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/15/Hexo-admin-%E6%8F%92%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Hexo admin 插件遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/14/%E7%8E%A9%E8%BD%ACBootstrap%E6%A1%86%E6%9E%B6/">玩转Bootstrap框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">多线程相关问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/12/Docker%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85T%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%EF%BC%88Tomcat%EF%BC%8CMysql%EF%BC%89/">Docker容器安装镜像文件（Tomcat，Mysql）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cache/">Cache</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Cache/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/">Maven</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/SpringMVC/">SpringMVC</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/SpringMVC/Spring/">Spring</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Maven/SpringMVC/Spring/Mybatis/">Mybatis</a><span class="category-list-count">1</span></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/springmvc/" style="font-size: 15px;">springmvc</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/%E5%8A%A8%E6%80%81SQL/" style="font-size: 15px;">动态SQL</a> <a href="/tags/Cache/" style="font-size: 15px;">Cache</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">多线程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/chaooo/hexo-theme-BlueLake" title="BlueLake主题" target="_blank">BlueLake主题</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright 2019&copy;<a href="/." rel="nofollow">Pxichen.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>